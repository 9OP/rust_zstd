use std::fs;
use std::path::Path;
use std::process::Command;

use zstd_lib::{self, ZstdLibError};

fn read_file(path: &str) -> Vec<u8> {
    let bytes = fs::read(path).unwrap();
    bytes
}

fn decode_file(path: &str) -> Result<Vec<u8>, ZstdLibError> {
    let bytes = read_file(path);
    zstd_lib::decode(bytes.as_slice(), false)
}

#[cfg(test)]
mod text {
    use super::*;

    #[test]
    fn test_mobydick() {
        let expected = read_file("./tests/txt/mobydick.txt");
        let decoded = decode_file("./tests/txt/mobydick.zst").unwrap();
        assert_eq!(expected, decoded);
    }
}

/*
    Golden decompression from:
    https://github.com/facebook/zstd/tree/dev/tests/golden-decompression
*/
#[cfg(test)]
mod golden {
    use super::*;

    #[test]
    fn test_block_128k() {
        let expected = read_file("./tests/golden/block-128k.bin");
        let decoded = decode_file("./tests/golden/block-128k.zst").unwrap();
        assert_eq!(expected, decoded);
    }

    #[test]
    fn test_empty_block() {
        let expected = read_file("./tests/golden/empty-block.bin");
        let decoded = decode_file("./tests/golden/empty-block.zst").unwrap();
        assert_eq!(expected, decoded);
    }

    #[test]
    fn test_rle_first_block() {
        let expected = read_file("./tests/golden/rle-first-block.bin");
        let decoded = decode_file("./tests/golden/rle-first-block.zst").unwrap();
        assert_eq!(expected, decoded);
    }
}

/*
    Compressed files generated by decode corpus tool:
    https://github.com/facebook/zstd/blob/dev/tests/decodecorpus.c
*/
#[cfg(test)]
mod decode_corpus {
    use super::*;

    const SCRIPT: &str = "./tests/generate_decoded_corpus.sh";
    const DECODED: &str = "./tests/decoded_corpus";
    const CORPUS: &str = "./tests/corpus";

    #[derive(Debug)]
    enum TestError<'a> {
        Zstd(ZstdLibError),
        Other(&'a str),
    }

    fn generate_decoded_corpus() {
        // Execute the Bash script
        let status = Command::new("bash")
            .arg(SCRIPT)
            .status()
            .expect("failed to execute script");

        if status.success() {
            println!("decoded corpus generated");
        } else {
            println!("decoded corpus generation failed: {}", status);
        }
    }

    #[test]
    fn test_corpus() {
        // Setup the decoded corpus from zstd for cross check
        generate_decoded_corpus();

        let mut errors = vec![];

        for entry in fs::read_dir(CORPUS).unwrap() {
            let file_name = entry.unwrap().file_name();
            let file_name_str = file_name.to_string_lossy();

            // Create paths for the input and output files
            let base_name = file_name_str.trim_end_matches(".zst");
            let input_file_path = Path::new(CORPUS).join(&file_name);
            let expected_output_file_path = Path::new(DECODED).join(format!("{}.bin", base_name));

            match decode_file(input_file_path.to_str().unwrap()) {
                Ok(decoded) => {
                    let expected = read_file(expected_output_file_path.to_str().unwrap());
                    if expected != decoded {
                        errors.push((input_file_path, TestError::Other("expected != decoded")));
                    }
                }
                Err(err) => errors.push((input_file_path, TestError::Zstd(err))),
            }
        }

        // Error reporting
        if errors.len() > 0 {
            for (p, err) in &errors {
                println!("{p:?}: {err:?}");
            }
            panic!("failed: {} corpus", errors.len());
        }
    }
}
